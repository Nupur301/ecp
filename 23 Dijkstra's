Represent a graph of city using adjacency matrix /adjacency list. Nodes should
represent the various landmarks and links should represent the distance between them.
Find the shortest path using Dijkstra&#39;s algorithm from single source to all destination.

#include <iostream>
#include <vector>
#include <limits>

using namespace std;

class Graph {
private:
    int V; // Number of landmarks
    vector<vector<int>> adjMatrix; // Adjacency matrix

public:
    Graph(int v) : V(v) {
        adjMatrix.resize(V, vector<int>(V, numeric_limits<int>::max()));
        for (int i = 0; i < V; ++i) {
            adjMatrix[i][i] = 0; // Distance to itself is 0
        }
    }

    void addEdge(int src, int dest, int weight) {
        adjMatrix[src][dest] = weight; // Directed graph
    }

    void dijkstra(int start);
};

// Dijkstra's algorithm
void Graph::dijkstra(int start) {
    vector<int> dist(V, numeric_limits<int>::max());
    vector<bool> visited(V, false);
    dist[start] = 0; // Start distance is 0

    for (int count = 0; count < V - 1; ++count) {
        // Find the unvisited vertex with the smallest distance
        int minDist = numeric_limits<int>::max(), u;
        for (int v = 0; v < V; ++v) {
            if (!visited[v] && dist[v] < minDist) {
                minDist = dist[v];
                u = v;
            }
        }

        visited[u] = true; // Mark as visited

        // Update distances to neighbors
        for (int v = 0; v < V; ++v) {
            if (!visited[v] && adjMatrix[u][v] != numeric_limits<int>::max() &&
                dist[u] + adjMatrix[u][v] < dist[v]) {
                dist[v] = dist[u] + adjMatrix[u][v];
            }
        }
    }

    // Print shortest distances
    cout << "Shortest distances from landmark " << start << ":\n";
    for (int i = 0; i < V; ++i) {
        cout << "Landmark " << i << ": " << dist[i] << " km\n";
    }
}

int main() {
    Graph city(5); // 5 landmarks
    city.addEdge(0, 1, 5); // A-B
    city.addEdge(0, 2, 10); // A-C
    city.addEdge(1, 2, 3); // B-C
    city.addEdge(1, 3, 2); // B-D
    city.addEdge(2, 3, 7); // C-D
    city.addEdge(2, 4, 8); // C-E
    city.addEdge(3, 4, 4); // D-E

    city.dijkstra(0); // Start from landmark A (0)

    return 0;
}
